<button id="ai-cancel-btn" onclick="cancelStreaming()">Cancel</button>
<span id="output" class="loading"></span>
<script>
    if (!window.aiStream) { console.error('C# Binding object not found'); }

    const outputDiv = document.getElementById('output');
    let cancelled = false;

    function cancelStreaming() {
        cancelled = true;
        window.aiStream.requestCancel().then(function () {
            document.getElementById('ai-cancel-btn').style.display = 'none';
            outputDiv.textContent = 'Cancelled';
            outputDiv.classList.remove('loading');
        });
    }

    function appendToTextOutput(str) {
        let lastMessageElement = getLastMessageElement();
        if (lastMessageElement) {
            getLastElement(lastMessageElement).textContent += str;
        }
    }

    function renderMarkDownAsHtml(strMarkDown) {
        window.aiStream.markdown2Html(strMarkDown).then(function (html) {
            getLastMessageElement().innerHTML = html;
            window.Prism.highlightAll();
        });
    }

    function getLastElement(el) {
        if (!el.lastElementChild) return el;
        return getLastElement(el.lastElementChild);
    }

    function getLastMessageElement()
    {
        let messages = document.querySelectorAll('es-message');
        let lastMessage = messages[messages.length - 1];
        return lastMessage;
    }

    // Add a new message bubble to the chat.
    function addMessage(role, content) {
        let newMessageElement = document.createElement('es-message');
        newMessageElement.setAttribute('data-role', currentRole);
        newMessageElement.innerText = content;
        outputDiv.appendChild(newMessageElement);
    }

    let currentRawOutput = '';
    let currentRole = '';

    function processNextChars(chars) {
        if (chars.includes('|||')) {
            items = chars.split('|||');
            for (let i = 0; i < items.length; i++) {
                processNextChars(items[i]);
            }
            return;
        }
        if (chars == '+-+NEWMESSAGE') {
            if (currentRawOutput != '') renderMarkDownAsHtml(currentRawOutput);
            currentRawOutput = '';
            let newMessageElement = document.createElement('es-message');
            newMessageElement.setAttribute('data-role', currentRole);
            outputDiv.appendChild(newMessageElement);
            return;
        }
        if (chars.startsWith("+-+ROLE,")) {
            let role = chars.split(",")[1];
            let messages = document.querySelectorAll('es-message');
            let lastMessage = messages[messages.length - 1];
            if (lastMessage) {
                lastMessage.setAttribute('data-role', role);
                currentRole = role;
            }
            return;
        }
        currentRawOutput += chars;
        if (chars.includes('\n')) {
            renderMarkDownAsHtml(currentRawOutput);
        } else {
            appendToTextOutput(chars);
        }
    }

    async function startStreaming() {
        try {

            var eSearchRenderTimer = new Date();

            function runCharacterStream() {
                window.aiStream.isFinishedStreaming().then(function (isFinished) {
                    if (!isFinished) {
                        // More to go
                        window.aiStream.getNextCharacters().then(function (nextChars) {
                            if (!cancelled) processNextChars(nextChars);
                            window.setTimeout(runCharacterStream, 10); // Gives thread some room to breath avoids tight loop
                        }).catch((error) => {
                            console.error(error);
                        });
                    } else {
                        // Finished or error
                        window.aiStream.getErrorString().then(function (errorStr) {
                            
                            if (errorStr != '') {
                                // Stream ended with an error.
                                const outputDiv = document.getElementById('output');
                                outputDiv.textContent = errorStr;
                                
                            } else {
                                // Stream ended successfully. Fetch any last characters in the buffer then perform a final render.
                                window.aiStream.getNextCharacters().then(function (nextChars) {
                                    processNextChars(nextChars);
                                    renderMarkDownAsHtml(currentRawOutput);
                                });
                            }
                            outputDiv.classList.remove('loading');
                            document.getElementById('ai-cancel-btn').remove();
                        });
                    }
                });
            }
            runCharacterStream();

        } catch (error) {
            console.error('Error during streaming:', error);
            const outputDiv = document.getElementById('output');
            outputDiv.textContent = 'Error: ' + error.message;
        }
    }

    startStreaming();
</script>